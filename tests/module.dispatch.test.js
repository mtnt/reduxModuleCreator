import { createStore, unlinkStore, RMCCtl, createModule, combineReducers, WrongInterfaceError } from '../dist';

import { getActionCreator, getUniquePath } from './helpers';

const payload0 = {
  name: 'payload0',
  value: true,
};
const payload1 = {
  name: 'payload1',
  value: false,
};
const initialData = {
  name: 'initial',
};
const VALID_CLASS = class SCtl extends RMCCtl {};
const MODULE_REDUCER = () => {
  return {
    name: 'initial',
  };
};

afterEach(() => {
  try {
    unlinkStore();
  } catch (e) {}
});

describe('module.dispatch', () => {
  it('called single time', () => {
    const actionCreator = getActionCreator();
    const ctlParams = [];

    const module = createModule({
      Ctl: VALID_CLASS,
      ctlParams,
      reducer: MODULE_REDUCER,
      actions: {
        action: { creator: actionCreator, type: actionCreator.actionType },
      },
    });
    const rootReducer = combineReducers({ [getUniquePath()]: module });
    const store = createStore(rootReducer);

    const dispatchSpy = jest.spyOn(store, 'dispatch');

    module.actions.action();

    expect(dispatchSpy).toHaveBeenCalledTimes(1);
  });

  it('called with autogenerated method named the same with action at root', () => {
    const actionCreator = getActionCreator();
    const ctlParams = [];

    const module = createModule({
      Ctl: VALID_CLASS,
      ctlParams,
      reducer: MODULE_REDUCER,
      actions: {
        action: { creator: actionCreator, type: actionCreator.actionType },
      },
    });
    const rootReducer = combineReducers({ [getUniquePath()]: module });
    const store = createStore(rootReducer);

    const dispatchSpy = jest.spyOn(store, 'dispatch');

    module.action();

    expect(dispatchSpy).toHaveBeenCalledTimes(1);
  });

  it('called with autogenerated method named the same with action at root while the Ctl has the same', () => {
    const actionCreator = getActionCreator();
    class Ctl extends RMCCtl {
      action() {}
    }
    const ctlParams = [];

    const module = createModule({
      Ctl,
      ctlParams,
      reducer: MODULE_REDUCER,
      actions: {
        action: { creator: actionCreator, type: actionCreator.actionType },
      },
    });
    const rootReducer = combineReducers({ [getUniquePath()]: module });
    const store = createStore(rootReducer);

    const dispatchSpy = jest.spyOn(store, 'dispatch');

    module.action();

    expect(dispatchSpy).toHaveBeenCalledTimes(0);
  });

  it('called several times with a same action but different payloads', () => {
    const actionCreator = getActionCreator();
    const ctlParams = [];

    const module = createModule({
      Ctl: VALID_CLASS,
      ctlParams,
      reducer: MODULE_REDUCER,
      actions: {
        action: { creator: actionCreator, type: actionCreator.actionType },
      },
    });
    const rootReducer = combineReducers({ [getUniquePath()]: module });
    const store = createStore(rootReducer);

    const dispatchSpy = jest.spyOn(store, 'dispatch');

    module.actions.action(payload0);

    expect(dispatchSpy).toHaveBeenCalledTimes(1);
    expect(dispatchSpy).toHaveBeenLastCalledWith({
      type: module.actions.action.actionType,
      payload: payload0,
    });

    module.actions.action(payload1);

    expect(dispatchSpy).toHaveBeenCalledTimes(2);
    expect(dispatchSpy).toHaveBeenLastCalledWith({
      type: module.actions.action.actionType,
      payload: payload1,
    });
  });

  it('called several times with totally same actions (including payloads)', () => {
    const actionCreator = getActionCreator();
    const ctlParams = [];

    const module = createModule({
      Ctl: VALID_CLASS,
      ctlParams,
      reducer: MODULE_REDUCER,
      actions: {
        action: { creator: actionCreator, type: actionCreator.actionType },
      },
    });
    const rootReducer = combineReducers({ [getUniquePath()]: module });
    const store = createStore(rootReducer);

    const dispatchSpy = jest.spyOn(store, 'dispatch');

    module.actions.action(payload0);
    module.actions.action(payload0);

    expect(dispatchSpy).toHaveBeenCalledTimes(2);
    expect(dispatchSpy).toHaveBeenLastCalledWith({
      type: module.actions.action.actionType,
      payload: payload0,
    });
  });

  it('called with an action that shouldn`t affect module`s state', () => {
    const stateDidUpdate = jest.fn();
    const actionCreator0 = getActionCreator();
    const actionCreator1 = getActionCreator();
    function reducer(state = initialData, action) {
      switch (action.type) {
        case actionCreator0.actionType:
          return action.payload;

        default:
          return state;
      }
    }
    class Ctl extends RMCCtl {
      stateDidUpdate(...args) {
        stateDidUpdate(...args);
      }
    }
    const ctlParams = [];

    const module = createModule({ Ctl, ctlParams, reducer, actions: {} });
    const rootReducer = combineReducers({ [getUniquePath()]: module });

    const store = createStore(rootReducer);

    store.dispatch(actionCreator1(payload1));

    // should not call `stateDidUpdate` at all
    expect(stateDidUpdate).toHaveBeenCalledTimes(0);
  });

  it('should work ok if called with an action without creator', () => {
    const stateDidUpdate = jest.fn();
    class Ctl extends RMCCtl {
      foo() {}
      stateDidUpdate(...args) {
        stateDidUpdate(...args);
      }
    }
    const ctlParams = [];
    const actions = {
      action0: {
        type: 'foo',
      },
    };
    const returnValue = 'bar';
    function reducer(state = initialData, action) {
      switch (action.type) {
        case this.actions.action0.actionType:
          return returnValue;

        default:
          return state;
      }
    }

    const module = createModule({ Ctl, ctlParams, reducer, actions });

    const rootReducer = combineReducers({ [getUniquePath()]: module });

    const store = createStore(rootReducer);

    module.actions.action0();

    expect(stateDidUpdate).toHaveBeenCalledTimes(1);
  });

  it('should use action with type based on specified', () => {
    const actionCreator = getActionCreator();
    const ctlParams = [];

    let module;

    const spy = jest.fn();
    const reducer = function (state = {}, action) {
      switch (action.type) {
        case module.actions.action.actionType:
          spy(action.payload);
      }
    };

    module = createModule({
      Ctl: VALID_CLASS,
      ctlParams,
      reducer,
      actions: {
        action: { creator: actionCreator, type: actionCreator.actionType },
      },
    });

    const rootReducer = combineReducers({ [getUniquePath()]: module });
    createStore(rootReducer);

    module.actions.action(payload0);

    expect(spy).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalledWith(payload0);
  });

  it('should throw an error while store is unlinked', () => {
    const actionCreator = getActionCreator();
    const ctlParams = [];

    const module = createModule({
      Ctl: VALID_CLASS,
      ctlParams,
      reducer: MODULE_REDUCER,
      actions: {
        action: { creator: actionCreator, type: actionCreator.actionType },
      },
    });
    const rootReducer = combineReducers({ [getUniquePath()]: module });

    createStore(rootReducer);

    unlinkStore();

    expect(() => {
      module.actions.action(payload0);
    }).toThrow(WrongInterfaceError);
  });

  it('should use proxied action', () => {
    const actionCreator = getActionCreator();
    const ctlParams = [];

    const innerModule = createModule({
      Ctl: VALID_CLASS,
      ctlParams,
      reducer: MODULE_REDUCER,
      actions: {
        innerAction: { creator: actionCreator, type: actionCreator.actionType },
      },
    });

    function outerReducer(state = {}, action, rootPath) {
      const innerPath = 'inner';

      return {
        [innerPath]: innerModule.integrator(innerPath)(state[innerPath], action, [rootPath, innerPath]),
      };
    }
    const outerModule = createModule({
      Ctl: VALID_CLASS,
      ctlParams,
      reducer: outerReducer,
      actions: {
        outerAction: { proxy: innerModule.actions.innerAction },
      },
    });

    const spy = jest.fn();

    function rootReducer(state = {}, action) {
      const outerPath = 'outer';

      spy(action);

      return {
        [outerPath]: outerModule.integrator(outerPath)(state[outerPath], action, outerPath),
      };
    }

    createStore(rootReducer);

    outerModule.actions.outerAction();

    expect(spy).toHaveBeenCalledTimes(2);
    expect(spy).toHaveBeenLastCalledWith({ type: innerModule.actions.innerAction.actionType });
  });
});
